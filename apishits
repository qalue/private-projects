local RepStore,RunService,UIS,Players,Lighting,ScriptContext,PerformanceStats,TeleportService,HttpService,MarketplaceService,VirtualUser,VirtualInputManager,CoreGui=game:GetService'ReplicatedStorage',game:GetService'RunService',game:GetService'UserInputService',game:GetService'Players',game:GetService'Lighting',game:GetService'ScriptContext',game:GetService'Stats'.PerformanceStats,game:GetService'TeleportService',game:GetService'HttpService',game:GetService'MarketplaceService',game:GetService'VirtualUser',game:GetService'VirtualInputManager',game.CoreGui;
local LP,StarterGui=Players.LocalPlayer,game.StarterGui;
local PlayerUI,Config=LP.PlayerGui
local C_R,C_C,R_Module,hook_func,fwait,tdelay,lstring,Mouse,Stepped,cframe,vector3,wrkspc,gs,tstring,xp_call,p_call,instance,Heartbeat,Character,MFloor,gc,setthreadidentity=coroutine.resume,coroutine.create,require,hookfunction,task.wait,task.delay,loadstring,LP:GetMouse(),RunService.Stepped,CFrame,Vector3,workspace,getsenv,tostring,xpcall,pcall,Instance,RunService.Heartbeat,LP.Character,math.floor,getconnections,set_thread_identity or setidentity or setthreadcontext or syn.set_thread_identity;
local Intellect,Intellect_Loaded={},false;

setmetatable(Intellect,{
    __index=function(_,Index)
        Intellect[Index]={};
        return Intellect[Index];
    end;
});

--> Game Modules
local TS=require(RepStore.TS);
TS.Timer:UnbindFromStep'CharacterAnimate';

getgenv().GUISettings={Rounds={Borders=false},Enemies={HitboxExtender=false,HitboxVisibility=false,Radar=false,ESP=false,},Settings={ToggleUIKey='RightShift',AutoSaveConfiguration=false},Character={Noclip=false,InfiniteJump=false,CurrentWalkSpeed=24,SprintSpeed=14,JumpPower=36},Gore={GibEnabled=false,BloodEnabled=false},Weapons={NoSpread=false,KillAll=false,KnifeAura=false,RequireKnife=false,NoRecoil=false,AllWeaponsAuto=false,InfiniteAmmo=false,NoBulletDrop=false,RapidAim=false,RapidFire=false,Aimbot={TriggerBot=false},SilentAim={Enabled=false,Type='Distance',AimPart='Head'}}}
getgenv().Connections={};
-->Load Settings
if not p_call(function()readfile('Intellect.cfg')end)then
    writefile('Intellect.cfg',HttpService:JSONEncode(GUISettings));
end;
GUISettings=HttpService:JSONDecode(readfile'Intellect.cfg');

--> Stupid Synapse X Crash Bypass
hookfunction(getrenv().PluginManager,function()
    return;
end);

Intellect.GameVersion=MarketplaceService:GetProductInfo(game.PlaceId).Name:split(' ')[5];
Intellect.Weapons.OldBulletDrop={};

function Intellect.Codes:RedeemAllCodes()
    local Codes=syn.request({Url='https://roblox-bad-business.fandom.com/wiki/Codes',Method='GET',Headers={['Content-Type']='application/json'}});
    Codes=Codes.Body:split('<td>');
    for Index=1,#Codes do 
        local Code=Codes[Index];
        if Index~=1 and Index%2==0 and Index~=26 then 
            local Code=Code:split('</td>')[1]:split('\n')[1];
            TS.Network:Invoke('Codes','Redeem',Code);
        end;
    end;
end;

function Intellect.Character:Deploy()
    firesignal(PlayerUI.MenuGui.Menu.Tiles.DeployButton.MouseButton1Click);
end;

function Intellect.Network:Fire(CMD)
    local ChatBar=LP.PlayerGui.Chat.Frame.ChatBarParentFrame.Frame.BoxFrame.Frame.ChatBar;
    ChatBar.Text='/e '..CMD;
    getconnections(ChatBar.FocusLost)[1].Function(true);
end;

function Intellect.Character:GetLocalCharacter()
    return TS.Characters:GetCharacter(LP)or false;
end;

function Intellect.Character:GetCharacter(Player)
    return TS.Characters:GetCharacter(Player)or false;
end;

function Intellect.Players:GetLoadedCharacters()
    local Players,Characters=Players:GetPlayers(),{};
    for i=1,#Players do 
        local Player=Players[i];
        Characters[#Characters+1]={Player=Player,Character=TS.Characters:GetCharacter(Player),IsPlayerFriendly=TS.Teams:ArePlayersFriendly(Player,LP)};
    end;
    return Characters;
end;


function Intellect.Enemies:GetCharacters()
    local Characters={};
    local Players=Intellect.Players:GetLoadedCharacters()
    for i=1,#Players do 
        local Player=Players[i];
        if not Player.IsPlayerFriendly and Player.Character then
            Characters[#Characters+1]=Player.Character;
        end;
    end;
    return Characters;
end;

function Intellect.ESP:Apply()
    p_call(function()
        local Players=Intellect.Players:GetLoadedCharacters()
        for i=1,#Players do 
            local Player=Players[i];
            if not Player.IsPlayerFriendly and Player.Character then
                local Parts=Player.Character.Body:GetChildren();
                if Player.Character.Body:FindFirstChild'Head'and not Player.Character.Body.Head:FindFirstChild'ESP'then
                    for i=1,#Parts do 
                        local Part=Parts[i];
                        Intellect.ESP:ApplyBox(Part,Color3.fromRGB(255,0,0));
                    end;
                end;
            end;
        end;
    end);
end;

function Intellect.Enemies:HitboxVisibility()
    local Players=Intellect.Enemies:GetCharacters();
    for i=1,#Players do 
        local Character=Players[i];
        if Character and Character:FindFirstChild'Hitbox'then 
            local Hitbox=Character.Hitbox:GetChildren()
            for i=1,#Hitbox do 
                Hitbox[i].Transparency=(GUISettings.Enemies.HitboxVisibility and .5)or 1;
            end;
        end;
    end;
end;

function Intellect.Enemies:HitboxExtender()
    local OriginalHitbox={Abdomen=Vector3.new(1.6,1.4,1.3),Chest=Vector3.new(1.9,1,1.6),Head=Vector3.new(1.5,1.6,1.5),Hips=Vector3.new(1.8,0.8,1.4),LeftArm=Vector3.new(1.05,1.9,1.05),LeftFoot=Vector3.new(1.1,0.9,1.6),LeftForearm=Vector3.new(1,1.9,1),LeftForeleg=Vector3.new(1.1,2.4,1.1),LeftHand=Vector3.new(1,1.1,1),LeftLeg=Vector3.new(1.2,2.4,1.2),Neck=Vector3.new(1,0.8,1),RightArm=Vector3.new(1.05,1.9,1.05),RightFoot=Vector3.new(1.1,0.9,1.6),RightForearm=Vector3.new(1,1.9,1),RightForeleg=Vector3.new(1.1,2.4,1.1),RightHand=Vector3.new(1,1.1,1),RightLeg=Vector3.new(1.2,2.4,1.2)};
    local Players=Intellect.Enemies:GetCharacters();
    for i=1,#Players do 
        local Character=Players[i];
        if Character and Character:FindFirstChild'Hitbox'then 
            local Hitbox=Character.Hitbox:GetChildren();
            if GUISettings.Enemies.HitboxExtender then 
                for i=1,#Hitbox do 
                    Hitbox[i].Size=Hitbox[i].Size*6;
                    Hitbox[i].BrickColor=BrickColor.new'Really red';
                end;
            else
                for i=1,#Hitbox do 
                    Hitbox[i].Size=OriginalHitbox[tostring(Hitbox[i])];
                end;
            end;
        end;
    end
end;

function Intellect.Aimbot:GetRandomPart(Character)
    local Character=Character:GetChildren()
    return Character[math.random(1,#Character)];
end;

function Intellect.Game:RejoinExperience()
    TeleportService:Teleport(game.PlaceId,LP);
end;

function Intellect.Character:NoClip()
    local Character=Intellect.Character:GetLocalCharacter();
    if Character and Character:FindFirstChild'Root'then 
        Character.Root.CanCollide=false;
    end;
end;

function Intellect.Character:IsWalking()
    local Keys={Enum.KeyCode.W,Enum.KeyCode.A,Enum.KeyCode.S,Enum.KeyCode.D,Enum.KeyCode.Space};
    for _,Key in next,Keys do
        if UIS:IsKeyDown(Key)then
            return Key;
        end;
    end;
    return false;
end;

function Intellect.Settings:SaveConfiguration()
    writefile('Intellect.cfg',HttpService:JSONEncode(GUISettings));
end;

function Intellect.ESP:ApplyBox(Instance1,Colour)
    local ESP=Instance.new('BoxHandleAdornment',Instance1);
    ESP.Name='ESP';
    ESP.Size=Instance1.Size;
    ESP.Adornee=Instance1;
    ESP.ZIndex=5;
    ESP.AlwaysOnTop=true;
    ESP.Color3=Colour;
    ESP.Transparency=.3;
end;

TS.Damage.CharacterKilled:Connect(function(Player)
    local PlayerChildren=Player.Body:GetChildren();
    for i=1,#PlayerChildren do 
        if PlayerChildren[i]:FindFirstChild'ESP'then 
            PlayerChildren[i].ESP:Destroy();
        end;
    end;
end);

function Intellect.ESP:Apply()
    p_call(function()
        local Players=Intellect.Players:GetLoadedCharacters()
        for i=1,#Players do 
            local Player=Players[i];
            if not Player.IsPlayerFriendly and Player.Character then
                local Parts=Player.Character.Body:GetChildren();
                if Player.Character.Body:FindFirstChild'Head'and not Player.Character.Body.Head:FindFirstChild'ESP'then
                    for i=1,#Parts do 
                        local Part=Parts[i];
                        Intellect.ESP:ApplyBox(Part,Color3.fromRGB(255,0,0));
                    end;
                end;
            end;
        end;
    end);
end;

function Intellect.ESP:Remove()
    p_call(function()
        local Players=Intellect.Players:GetLoadedCharacters()
        for i=1,#Players do 
            local Player=Players[i];
            if not Player.IsPlayerFriendly and Player.Character then
                local Parts=Player.Character.Body:GetChildren();
                if Player.Character.Body:FindFirstChild'Head'then
                    for i=1,#Parts do 
                        local Part=Parts[i];
                        if Part:FindFirstChild'ESP'then
                            Part.ESP:Destroy();
                        end;
                    end;
                end;
            end;
        end;
    end);
    Intellect:Disconnect'ESP';
end;

function Intellect.Weapons:GetEquippedWeapon()
    local Character=TS.Characters:GetCharacter(LP);
    if Character and Character:FindFirstChild'Backpack'then 
        local Weapons=Character.Backpack.Items:GetChildren();
        for i=1,#Weapons do 
            local Weapon=Weapons[i];
            local Check=(tostring(Weapon)==tostring(Character.Backpack.Equipped.Value));
            if Check then 
                return Weapon;
            end;
        end;
    end;
    return false;
end;

function Intellect.Character:AntiAim()
    local Pose=math.random(-1,1)
    TS.Network:Fire('Character','State','Lean',Pose)
end;

function Intellect.Weapons:NoBulletDrop(State)
    local gc,Index=getgc(true),0;
    for i=1,#gc do 
        local Weapon=gc[i];
        if type(Weapon)=='table'and rawget(Weapon,'Gravity')and rawget(Weapon,'Speed')then
            if #Intellect.Weapons.OldBulletDrop~=12 then 
                Intellect.Weapons.OldBulletDrop[#Intellect.Weapons.OldBulletDrop+1]=Weapon.Gravity;
            end;
            Index+=1;Weapon.Gravity=(State and Intellect.Weapons.OldBulletDrop[Index])or 0;
        end;
    end;
end;

function Intellect.Weapons:InfiniteAmmo()
    local Weapon=Intellect.Weapons:GetEquippedWeapon();
    if Weapon and Weapon:FindFirstChild'Events'and not Weapon.Events:FindFirstChild'Stab'then
        TS.Network:Fire('Item_Paintball','Reload',Weapon);
        if Weapon.State.Ammo.Value==0 then 
            Weapon.State.Ammo.Value=RepStore.Items.Base:FindFirstChild(tstring(Weapon)).State.Ammo.Value;
        end;
    end;
end;

function Intellect.Enemies:Radar()
    p_call(function()
        local Players,Min=Intellect.Players:GetLoadedCharacters(),9e9;
        for i=1,#Players do 
            local Player=Players[i];
            if not Player.IsPlayerFriendly and Player.Character and Intellect.Character:GetLocalCharacter()then
                TS.UI.Events.RadarEnemy:Fire(tick(),Player.Character.Body.Head.CFrame.p);
            end;
        end;
    end);
end;

function Intellect.Enemies:FindNearestTargetToMouse()
    local _,NearestCharacter,NearestPlayer=p_call(function()
    local Players,Min=Intellect.Players:GetLoadedCharacters(),9e9;
    for i=1,#Players do 
        local Player=Players[i];
        if not Player.IsPlayerFriendly and Player.Character and not Player.Character.Root:FindFirstChild'ParticleEmitter'and tstring(Player.Character.Parent)=='Characters'and Intellect.Character:GetLocalCharacter()then
            local Character=Player.Character;
            if Character and Character.Health.Value>0 then
            local ScreenPosition,IsVisibleOnViewPort=workspace.Camera:WorldToViewportPoint(Character.Body.Head.Position);
                if IsVisibleOnViewPort then
                    local Distance=(Vector2.new(Mouse.X,Mouse.Y)-Vector2.new(ScreenPosition.X,ScreenPosition.Y)).Magnitude;
                    if Distance<Min then NearestCharacter=Player.Character;NearestPlayer=Player.Player;end;
                    end;
                end;
            end;
        end;
        return NearestCharacter,NearestPlayer;
    end);
    return NearestCharacter,NearestPlayer;
end;

function Intellect.Enemies:FindNearestTarget()
    local _,NearestCharacter,NearestPlayer,Distance=p_call(function()
        local Players,Min=Intellect.Players:GetLoadedCharacters(),9e9;
        for i=1,#Players do 
            local Player=Players[i];
            if not Player.IsPlayerFriendly and Player.Character and not Player.Character.Root:FindFirstChild'ParticleEmitter'and tstring(Player.Character.Parent)=='Characters'and Intellect.Character:GetLocalCharacter()then
                if(Player.Character.Body.Head.CFrame.p-Intellect.Character:GetLocalCharacter().Body.Head.CFrame.p).Magnitude<Min then 
                    Min=(Player.Character.Body.Head.CFrame.p-Intellect.Character:GetLocalCharacter().Body.Head.CFrame.p).Magnitude;
                    NearestCharacter,NearestPlayer=Player.Character,Player.Player;
                end;
            end;
        end;
        return NearestCharacter,NearestPlayer,MFloor(Min);
    end);
    return NearestCharacter,NearestPlayer,Distance;
end;

function Intellect.Weapons:Shoot(Bool)
    VirtualInputManager:SendMouseButtonEvent(0,0,0,Bool,game,0);
    VirtualInputManager:SendMouseButtonEvent(0,0,0,Bool,game,0);
end;

function Intellect.Weapons:GetGunModel()
    local Items=workspace:GetChildren();
    for i=1,#Items do 
        local Item=Items[i];
        if Item:IsA'Model'and tstring(Item)~='Arms'and Item:FindFirstChild'RightHand'then
            return Item;
        end;
    end;
    return false;
end;

function Intellect.Character:Jump(Amount)
    local Character=Intellect.Character:GetLocalCharacter();
    if Character and Character:FindFirstChild'Root'then
        local Amount=Amount or GUISettings.Character.JumpPower;
        Character.Root.Velocity=Vector3.new(Character.Root.Velocity.X,Amount,Character.Root.Velocity.Z);
        VirtualInputManager:SendKeyEvent(true,'Space',false,game)
        fwait()
        VirtualInputManager:SendKeyEvent(false, 'Space', false, game)
	end;
end;

function Intellect.Character:Teleport(CF)
    local Character=Intellect.Character:GetLocalCharacter();
    Intellect.Character:Jump(200)
    if Character and Character:FindFirstChild'Root'then
        Character.Root.CFrame=CF;
    end;
end;

function Intellect.Weapons:Equip(Weapon)
    TS.Network:Fire('Item','Equip',Weapon);
end;

function Intellect.Enemies:KillAll()
    return'Not Finished';
end;

function Intellect.Weapons:ImpactPoint(Part)
    local ImpactPoint=Instance.new('Part',Part);
    Part.Decal:Destroy()
    ImpactPoint.BrickColor=BrickColor.new('Really red');
    ImpactPoint.Size=Part.Size/2;
    ImpactPoint.CFrame=Part.CFrame;
    ImpactPoint.Material=Enum.Material.Neon
    ImpactPoint.Anchored=true;
end;

function Intellect.Weapons:TriggerBot()
    p_call(function()
        local Players=Intellect.Players:GetLoadedCharacters();
        Mouse.TargetFilter=Intellect.Weapons:GetGunModel();
        for i=1,#Players do 
            local Player=Players[i];
            if not Player.IsPlayerFriendly and Player.Character and Intellect.Character:GetLocalCharacter()then
                print(Mouse.Target)
                if Mouse.Target and Mouse.Target:IsDescendantOf(Player.Character)then 
                    repeat RunService.Stepped:wait()Intellect.Weapons:Shoot(true);until Mouse.Target and Mouse.Target~=Mouse.Target:IsDescendantOf(Player.Character);
                    Intellect.Weapons:Shoot(false);
                end;
            end;
        end;
    end);
end;

function Intellect.Weapons:GetMelee()
    local Character=Intellect.Character:GetLocalCharacter()
    if Character then 
        local Weapons=Character.Backpack.Items:GetChildren()
        for i=1,#Weapons do 
            local Melee=Weapons[i];
            if Melee.Events:FindFirstChild'Stab'then 
                return Melee;
            end;
        end;
    end;
    return false;
end;

function Intellect:Loop(Name,Function)
    Connections[Name]=RunService.Stepped:Connect(Function);
end;

function Intellect.Rounds:RemoveBorders()
    local Borders=workspace.NonProjectileGeometry:GetChildren()
    for i=1,#Borders do 
        Borders[i]:Destroy();
    end;
end;

function Intellect.Weapons:GetGrenade()
    local Character=Intellect.Character:GetLocalCharacter()
    if Character then 
        local Weapons=Character.Backpack.Items:GetChildren()
        for i=1,#Weapons do 
            local Grenade=Weapons[i];
            if Grenade.State:FindFirstChild'Cooking'then 
                return Grenade;
            end;
        end;
    end;
    return false;
end;

function Intellect.Character:IsMeleeEquipped()
    local Melee=Intellect.Weapons:GetMelee()
    local Character=Intellect.Character:GetLocalCharacter();
    if Character then
        return(tstring(Melee)==tstring(Character.Backpack.Equipped.Value));
    end;
end;

function Intellect.Character:IsGrenadeEquipped()
    local Grenade=Intellect.Weapons:GetGrenade()
    local Character=Intellect.Character:GetLocalCharacter();
    if Character then
        return(tstring(Grenade)==tstring(Character.Backpack.Equipped.Value));
    end;
end;

function Intellect:Disconnect(Name)
    Connections[Name]:Disconnect();
end;

function Intellect.Weapons:NoSpread()
    local Character=Intellect.Character:GetLocalCharacter();
    if Character and Character:FindFirstChild'Root'and not Intellect.Character:IsMeleeEquipped()and not Intellect.Character:IsGrenadeEquipped()then
        Character.State.Aiming.Value=true;
    end;
end;

function Intellect.Weapons:KnifeTarget(Player)
    local NearestCharacter,NearestPlayer,Distance,OldWeapon=Intellect.Enemies:FindNearestTarget();
    if Player or NearestCharacter and Distance and Distance<28 and Intellect.Character:GetLocalCharacter()then 
        NearestCharacter=NearestCharacter or Player;
        local Health=NearestCharacter.Health.Value;
        TS.Network:Fire('Item_Melee','StabBegin',Intellect.Weapons:GetMelee());
        TS.Network:Fire('Item_Melee','Stab',Intellect.Weapons:GetMelee(),NearestCharacter.Hitbox.Head,Vector3.new(),Vector3.new());
        fwait(.2);
        if NearestCharacter.Health.Value~=Health then
            TS.UI.Events.Hitmarker:Fire(NearestCharacter.Body.Head);
        end;
    end;
end;

function Intellect.Character:ResetCharacter()
    Intellect.Character:Teleport(CFrame.new(0,-497,0))
end;

function Intellect.Weapons:ApplyWeaponModification(Tbl,Index,Value)
    local Items=RepStore.Items.Base:GetChildren();  
    for i=1,#Items do 
        if Items[i]:FindFirstChild'Config'then
            local Module=require(Items[i].Config);
            if typeof(Module.Recoil)=='table'and Module.Recoil.Default and Module.Aim and Module then
                if Tbl=='self'then 
                    rawset(Module,'FireModeList',{'Auto'})
                    if Module.FireModes.Semi then
                        rawset(Module.FireModes,'Auto',{FireRate=Module.FireModes.Semi.FireRate});
                    end;
                elseif Tbl=='Recoil'then 
                    for Index,Weapon in next,Module.Recoil.Default do
                        rawset(Module.Recoil.Default,Index,(typeof(Weapon)=='Vector3'and Vector3.new()or typeof(Weapon)=='Vector2'and Vector2.new())or 0);
                    end;
                else
                    local Operator=string.find(Value,'x');
                    local Key=(Operator and'x')or'/';
                    rawset(Module[Tbl],Index,(Operator and Module[Tbl][Index]*tonumber(Value:split(Key)[2]))or not Operator and Module[Tbl][Index]/tonumber(Value:split(Key)[2])or Value);
                end;
            end;
        end;
    end;
end;
return Intellect;
